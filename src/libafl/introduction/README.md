# Introduction

So, you want to learn how to use
[LibAFL](https://github.com/AFLplusplus/LibAFL)! Welcome to the future of
fuzzing. You can read all about [LibAFL](https://github.com/AFLplusplus/LibAFL)
and the features it offers on their [github](https://github.com/AFLplusplus/LibAFL)
page, but the highlights are:

- Fast: LibAFL lets you create the fastest fuzzers possible, with minimal overhead.
- Rust: Take advantage of the Rust language and ecosystem, including package management
  and robust FFI.
- Scaling: LibAFL scales across cores and machines by default.
- Any platform: LibAFL runs on Windows, Linux, Android, MacOS, and embedded environments.
- *Any* target: LibAFL can fuzz targets on any platform it runs on, and any other
  platform by creating remote harnesses. Fuzz FPGAs, UEFI firmware, Web Apps, and more,
  with or without source code.
- Customizable: LibAFL gives you robust building blocks to assemble powerful fuzzers,
  but every component can be swapped out and customized for your use case or for maximum
  performance.

Some additional excellent resources on LibAFL are below.

- [LibAFL Repository](https://github.com/AFLplusplus/LibAFL)
- [LibAFL Documentation](https://docs.rs/libafl/latest/libafl/)
- [LibAFL Book (Incomplete)](https://aflplus.plus/libafl-book)
- [Fuzzing101 Blog Posts](https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/)
- [LibAFL Paper](https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf)